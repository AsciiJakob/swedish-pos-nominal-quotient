<!DOCTYPE html>
<html>
    <head>
        <script src="compiled_computed_tags.js"></script>
    </head>
    <body>
        <div id="sideData">
            <h3 id="fullNominalQuotient">laddar</h3>
            <h3 id="simpleNominalQuotient">laddar</h3>
            <h3 id="verbNounCount">laddar</h3>
            <h3 id="wordCount">laddar</h3>
            <h3 id="meanSentenceLength">laddar</h3>
            <div id="settingsContainer">
                <fieldset id="modelSelector">
                    <legend>Ordklasstaggningsmodell:</legend>
                    <!-- <input type="radio" name="model" id="flair"> <label for="flair">Flair</label>
                    <input type="radio" name="model" id="kb_bert"> <label for="kb_bert">KB-Bert</label> -->
                </fieldset>
                <legend>År/betyg, text</legend>
                <select id="fileSelector" size="10" name="fileID"><option>test</option><option>test</option></select>
                <select id="textSelector" size="10" name="textID"></select>
            </div>
            
        </div>
        <!-- generated by gpt from screenshot of docx table, TODO: use lookup for hovering -->
        <table class="category-table"><thead><tr><th>Code</th><th>Swedish category</th><th>Example</th></tr></thead><tbody><tr><td>AB</td><td>Adverb</td><td>inte</td></tr><tr><td>DT</td><td>Determinerare</td><td>denna</td></tr><tr><td>HA</td><td>Frågande/relativt adverb</td><td>när</td></tr><tr><td>HD</td><td>Frågande/relativt determinera</td><td>vilken</td></tr><tr><td>HP</td><td>Frågande/relativt pronomen</td><td>som</td></tr><tr><td>HS</td><td>Frågande/relativt possessivt pronomen</td><td>vars</td></tr><tr><td>IE</td><td>Infinitivmärke</td><td>att</td></tr><tr><td>IN</td><td>Interjektion</td><td>ja</td></tr><tr><td>JJ</td><td>Adjektiv</td><td>gul</td></tr><tr><td>KN</td><td>Konjunktion</td><td>och</td></tr><tr><td>NN</td><td>Substantiv</td><td>pudding</td></tr><tr><td>PC</td><td>Particip</td><td>utsänd</td></tr><tr><td>PL</td><td>Partikel</td><td>ut</td></tr><tr><td>PM</td><td>Egenamn</td><td>Mats</td></tr><tr><td>PN</td><td>Pronomen</td><td>hon</td></tr><tr><td>PP</td><td>Preposition</td><td>av</td></tr><tr><td>PS</td><td>Possessivt pronomen</td><td>hennes</td></tr><tr><td>RG</td><td>Grundtal</td><td>tre</td></tr><tr><td>RO</td><td>Ordningstal</td><td>tredje</td></tr><tr><td>SN</td><td>Subjunktion</td><td>att</td></tr><tr><td>UO</td><td>Utländskt ord</td><td>jeans</td></tr><tr><td>VB</td><td>Verb</td><td>kasta</td></tr></tbody></table>
    <div id="textContent">
    </div>

    </body>
</html>

<script>

const textContent = document.getElementById("textContent");
const numerator = ["NN", "PM", "PP", "PC"];
const denominator = ["PN", "PS", "VB", "AB"];

const params = new URLSearchParams(window.location.search);
let currentModel = params.get("model") || Object.keys(dataFile)[0];
let currentFile = params.get("fileID") || 0 
let currentTextID = params.get("textID") || 0;
updateURL();
setSettingsVisuals();

renderSentences();

// store application states in url since refreshing is great but losing your state isn't.
function updateURL() {
    // const newUrl = `?model=${encodeURIComponent(currentModel)}&textID=${encodeURIComponent(currentTextID)}`;
    const newUrl = `?model=${encodeURIComponent(currentModel)}&fileID=${encodeURIComponent(currentFile)}&textID=${encodeURIComponent(currentTextID)}`;
    window.history.pushState(null, '', newUrl);
}

// settings-related things
document.getElementById("settingsContainer").addEventListener("change", mouseEvent => handleSetting(mouseEvent.target));
function handleSetting(settingElement) {
    if (settingElement.name == "model") {
        if (dataFile[settingElement.id] == undefined) {
            document.getElementById(currentModel).checked = true;
            alert("Det finns ingen data från modellen i datafilen.");
            return;
        }
        if (dataFile[settingElement.id][currentFile].texts.length-1 < currentTextID) {
                // alert("Den för närvarande valda texten har inte analyserats med denna modell.");
                // doment.getElementById(currentModel).checked = true;
                // return;
                currentTextID = 0;
        }
        currentModel = settingElement.id;
        updateURL();
        setSettingsVisuals(); // update the text options to match current model (in case they have anaylized different corpuses)
        renderSentences();
    }


    if (settingElement.name == "fileID") {
        if (dataFile[currentModel].length-1 < settingElement.value) {
            alert("Något gick snett");
            return;
        }
        currentFile = settingElement.value;
        updateURL();
        setSettingsVisuals();
        renderSentences();
    };


    if (settingElement.name == "textID") {
        if (dataFile[currentModel][currentFile].texts.length-1 < settingElement.value) {
            alert("Den här texten har inte analyserats med den modell som är vald.");
            return;
        }
        currentTextID = settingElement.value;
        updateURL();
        setSettingsVisuals();
        renderSentences();
    }
}

function setSettingsVisuals() {

    // add file names
    const fileSelector = document.getElementById("fileSelector");
    const oldValue = fileSelector.value;
    fileSelector.innerText = "";
    for (fileIndex in dataFile[currentModel]) {
        const file = dataFile[currentModel][fileIndex];
        fileOption = document.createElement("option");
        fileOption.value = fileIndex;
        fileOption.name = "fileID";
        fileOption.innerText = file.filename;
        fileSelector.appendChild(fileOption);
    }
    fileSelector.value = oldValue;


    // add texts
    const textSelector = document.getElementById("textSelector");
    textSelector.innerText = "";
    for (textIndex in dataFile[currentModel][currentFile].texts) {
        const text = dataFile[currentModel][currentFile].texts[textIndex];
        textOption = document.createElement("option");
        textOption.value = textIndex;
        textOption.name = "textID";
        textOption.innerText = text.id;
        textSelector.appendChild(textOption);
    }

    
    // add models
    const modelSelector = document.getElementById("modelSelector");
    modelSelector.innerText = "";
    const legend = document.createElement("legend");
    legend.innerText = "Ordklasstaggningsmodell:"
    modelSelector.appendChild(legend);
    for (modelName of Object.keys(dataFile)) {
        const modelElement = document.createElement("input");
        modelElement.id = modelName;
        modelElement.name = "model";
        modelElement.type = "radio";

        const modelLabel = document.createElement("label");
        modelLabel.innerText = modelName;
        modelLabel.htmlFor = modelName;

        modelSelector.appendChild(modelElement);
        modelSelector.appendChild(modelLabel);
    }

    // set the models radio dial to selected 
    document.getElementById(currentModel).checked = true;

    document.getElementById("textSelector").value = currentTextID;
}

function renderSentences() {
    const sentences = dataFile[currentModel][currentFile].texts[currentTextID].sentences
    let countNouns = 0;
    let countVerbs = 0;

    textContent.innerText = "";
    for (sentence of sentences) {
        const sentenceElement = document.createElement("div");
        sentenceElement.classList = "sentence"
        for (let i=0; i < sentence.length; i++) {
            const word = sentence[i]

            const wordDiv = document.createElement("div");
            wordDiv.classList = "tooltip";
            wordDiv.innerText = word.word;

            if (numerator.includes(word.entity_group)) {
                wordDiv.classList+=" numerator"
            }
            if (denominator.includes(word.entity_group)) {
                wordDiv.classList+=" denominator"
            }

            if (word.entity_group == "NN")
                countNouns++;
            if (word.entity_group == "VB")
                countVerbs++;

            const tooltip = document.createElement("span");
            tooltip.classList = "tooltipText";
            tooltip.innerText = word.entity_group;
            const full = fullTagName(word.entity_group);
            if (full != undefined)
                tooltip.innerText += ": "+full;
            
            
            wordDiv.appendChild(tooltip);
            sentenceElement.appendChild(wordDiv);
            if (i != sentence.length-1 && sentence[i+1].entity_group != "MAD") {
                sentenceElement.innerHTML += " "
            }
        }
        textContent.appendChild(sentenceElement);

        const spacer = document.createElement("br");
        textContent.appendChild(spacer);
    }

    // set metric values
    const currentText = dataFile[currentModel][currentFile].texts[currentTextID];
    document.getElementById("verbNounCount").innerText = "Verb: "+countVerbs+" substantiv: "+countNouns;
    document.getElementById("fullNominalQuotient").innerText = "Full nominalkvot: " + currentText.full_nominal_quotient;
    document.getElementById("simpleNominalQuotient").innerText = "Enkel nominalkvot: " + currentText.simple_nominal_quotient;
    document.getElementById("wordCount").innerText = "Antal ord: " + currentText.word_count;
    document.getElementById("meanSentenceLength").innerText = "Genomsnittlig meningslängd: " + currentText.mean_sentence_length;
}



function fullTagName(tag) {
// generated by gpt
    const tagMapping = {
        'AB': 'Adverb',
        'DT': 'Determinerare',
        'HA': 'Frågande/relativt adverb',
        'HD': 'Frågande/relativt determinera',
        'HP': 'Frågande/relativt pronomen',
        'HS': 'Frågande/relativt possessivt pronomen',
        'IE': 'Infinitivmärke',
        'IN': 'Interjektion',
        'JJ': 'Adjektiv',
        'KN': 'Konjunktion',
        'NN': 'Substantiv',
        'PC': 'Particip',
        'PL': 'Partikel',
        'PM': 'Egenamn',
        'PN': 'Pronomen',
        'PP': 'Preposition',
        'PS': 'Possessivt pronomen',
        'RG': 'Grundtal',
        'RO': 'Ordningstal',
        'SN': 'Subjunktion',
        'UO': 'Utländskt ord',
        'VB': 'Verb'
    };

    return tagMapping[tag] || undefined;
}

</script>

<style>
body {
    background-color: #ffe7c8;
}
#sideData {
    width: 20%;
    float: right;
    position: fixed;
    top: 0;
    right:0;
}
#fileSelector {
    width: 10%;
}
#textSelector {
    width: 20%;
}
#textContent {
  margin: auto;
  width: 40%;
  font-size: 1.5em;
}
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted black;
  white-space: pre;
}

.tooltip .tooltipText {
  visibility: hidden;
  /* width: 220px; */
  width: auto;
  background-color: black;
  color: #fff;
  text-align: center;
  padding: 5px 0;
  border-radius: 6px;
 
  position: absolute;
  z-index: 1;
}

.tooltip:hover .tooltipText {
  visibility: visible;
}
.tooltip:hover {
    background-color: rgb(105, 105, 105);
}


.denominator {
    color: orange;
}
.numerator {
        color: #69ae00
}


.category-table {
    border-collapse: collapse;
    width: 250px; /* Adjust width as needed */
    margin-right: 20px; /* Space between table and rest of the content */

    float: left;
    position: fixed;
}

.category-table th, .category-table td {
    border: 1px solid black;
    padding: 8px;
    text-align: left;
}

.category-table th {
    background-color: #f2f2f2;
}

</style>